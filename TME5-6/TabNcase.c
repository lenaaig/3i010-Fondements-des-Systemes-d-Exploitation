/* Diffusion tampon N case */

  #include <stdio.h> 
  #include <unistd.h> 
  #include <signal.h> 
  #include <libipc.h>

/************************************************************/

/* definition des parametres */ 

  #define NE          2     /*  Nombre d'emetteurs         */ 
  #define NR          5     /*  Nombre de recepteurs       */ 
  #define NMAX        3     /*  Taille du tampon           */ 

/************************************************************/

/* definition des semaphores */ 

	#define EMET 0 //Recepteurs
	#define MUTEXE 1 //Pour proteger id

	int RECEP[NR]; //Bloquant
	int CASE[NMAX]; //CS(1)

/************************************************************/

/* definition de la memoire partagee */ 
typedef struct {
	int id;
    int msg[NMAX];
	int nb_recepteurs[NMAX];
  } t_segpart;
  t_segpart *sp; /* Pointeur sur le segment */

/************************************************************/

/* variables globales */ 
    int emet_pid[NE], recep_pid[NR]; 
	t_segpart tampon[NMAX];


/************************************************************/

/* traitement de Ctrl-C */ 

  void handle_sigint(int sig) 
  { int i;
  	for (i = 0; i < NE; i++) kill(emet_pid[i], SIGKILL); 
	for (i = 0; i < NR; i++) kill(recep_pid[i], SIGKILL); 
	det_sem(); 
	det_shm((char *)sp); 
 
  } 

/************************************************************/

/* fonction EMETTEUR */ 

	// A completer - contient les instructions executees
        // par un emetteur

	void emetteur(int i){
		int cpt = i*1000;
		int y;
		while(1){
			sleep(3);
			P(EMET);
			
			P(MUTEXE); 	//PROTEGE id (parcours du tampon)
			int tmp = sp->id;  //RESERVE LA CASE
			sp->id=(sp->id+1)%NMAX;
			V(MUTEXE);
			
			sp->msg[tmp]=cpt;
			cpt++;

			printf("emetteur %d a ecrit %d sur la case %d.\n",i, sp->msg[tmp], tmp);
			//Reveil des recepteurs:
			for (y=0; y<NR; y++){
				V(RECEP[y]);
			}
			
		}	
	}

/************************************************************/

/* fonction RECEPTEUR */ 

	// A completer - contient les instructions executees
        // par un recepteur
	void recepteur(int idR){
		int j=0;		
		while(1){
			
			P(RECEP[idR]); //Attend qu'il y ait un message			

			P(CASE[j]);
			printf("recepteur %d : %d sur la case %d.\n",idR,sp->msg[j],j);
			sp->nb_recepteurs[j]++;
			if(sp->nb_recepteurs[j] == NR){
				sp->nb_recepteurs[j]=0;
				V(EMET);
			}
			V(CASE[j]);
			j=(j+1)%NMAX;
		}
	}

/************************************************************/

int main() { 
     struct sigaction action;
    /* autres variables (a completer) */
    
    setbuf(stdout, NULL);

/* Creation du segment de memoire partagee */
	int i;
	if ( (sp = (t_segpart *) init_shm(sizeof(t_segpart))) == NULL) {
		perror("init_shm");
		exit(1);
	}
	sp->id=0;
	for(i=0;i<NMAX;i++){
		sp->msg[i]=0;
		sp->nb_recepteurs[i]=0;
	}
	

/* creation des semaphores */ 


	for (i=2; i<NR+2; i++){
		RECEP[i-2]=i;
	}
	for(i=NR+2; i<(NR+2)+NMAX; i++){
		CASE[i-(NR+2)]=i;
	}
	
	if (creer_sem(NR+2+NMAX) == -1) {
		perror("creer_sem");
		exit(1);
	}


/* initialisation des semaphores */ 


	init_un_sem(EMET,NE);
	init_un_sem(MUTEXE,1);

	for (i=0; i<NR; i++){
		init_un_sem(RECEP[i],0);
	}

	for (i=0; i<NMAX; i++){
		init_un_sem(CASE[i],1);
	}

/* creation des processus emetteurs */ 

	// A completer - les pid des processus crees doivent
        // etre stockes dans le tableau emet_pid

	for(i=0;i<NE;i++){
		if((emet_pid[i]=fork())==0){
			emetteur(i);
			exit(1);
		}
	}

/* creation des processus recepteurs */ 

	// A completer - les pid des processus crees doivent
        // etre stockes dans le tableau recep_pid
	for(i=0;i<NR;i++){
		if ( (recep_pid[i]=fork())==0 ){
			recepteur(i);
			exit(1);
		}
	}


/* redefinition du traitement de Ctrl-C pour arreter le programme */ 

    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    action.sa_handler = handle_sigint;
    sigaction(SIGINT, &action, 0); 
    
    pause();                    /* attente du Ctrl-C  */
		det_sem();
		det_shm(sp);
    return EXIT_SUCCESS;
} 
