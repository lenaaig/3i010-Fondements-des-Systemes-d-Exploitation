/* Diffusion tampon 1 case */

  #include <stdio.h> 
  #include <unistd.h> 
  #include <stdlib.h> 
  #include <signal.h> 
  #include <libipc.h>

/************************************************************/

/* definition des parametres */ 

  #define NE          2     /*  Nombre d'emetteurs         */ 
  #define NR          5     /*  Nombre de recepteurs       */ 
  
/************************************************************/

/* definition des semaphores */ 

	#define EMET 0
	#define MUTEX 1 
	int RECEP[NR]; 

/************************************************************/

/* definition de la memoire partagee */ 

  typedef struct {
    int msg;
		int nb_recepteurs;
  } t_segpart;
  t_segpart *sp; /* Pointeur sur le segment */

	

/************************************************************/

/* variables globales */ 
    int emet_pid[NE], recep_pid[NR]; 

/************************************************************/

/* traitement de Ctrl-C */ 

  void handle_sigint(int sig) { 
      int i;
      for (i = 0; i < NE; i++) kill(emet_pid[i], SIGKILL); 
      for (i = 0; i < NR; i++) kill(recep_pid[i], SIGKILL); 
      det_sem(); 
      det_shm((char *)sp); 
  } 

/************************************************************/

/* fonction EMETTEUR */ 

	// A completer - contient les instructions executees
        // par un emetteur
	void emetteur(int i){
		int cpt = i*10000;
		int y;
		while(1){
			sleep(3);
			P(EMET); //Exclusion mutuelle avec les autres emetteurs 
			sp->msg=cpt;
			cpt++;
			printf("emetteur\n");
			//Reveil des recepteurs:
			for (y=0; y<NR; y++){
				V(RECEP[y]);
			}
			
		}	
	}

/************************************************************/

/* fonction RECEPTEUR */ 

	// A completer - contient les instructions executees
        // par un recepteur
	void recepteur(int i){
		while(1){
			P(RECEP[i]); //Attend qu'il y ait un message			
			printf("%d \n",sp->msg);
			P(MUTEX);
			sp->nb_recepteurs++;
			if(sp->nb_recepteurs == NR){
				sp->nb_recepteurs=0;
				V(EMET);
			}
			V(MUTEX);
		}
	}

/************************************************************/

int main() { 
    struct sigaction action;
    /* autres variables (a completer) */
    
    setbuf(stdout, NULL);

/* Creation du segment de memoire partagee */

	if ( (sp = (t_segpart *) init_shm(sizeof(t_segpart))) == NULL) {
		perror("init_shm");
		exit(1);
	}
	sp->msg = 0;

/* creation des semaphores */ 

	int i;
	for (i=2; i<NR+2; i++){
		RECEP[i-2]=i;
	}
	
	if (creer_sem(NR+2) == -1) {
		perror("creer_sem");
		exit(1);
	}


/* initialisation des semaphores */ 

	init_un_sem(EMET,1);
	init_un_sem(MUTEX,1);

	for (i=0; i<NR; i++){
		init_un_sem(RECEP[i],0);
	}

/* creation des processus emetteurs */ 

	// A completer - les pid des processus crees doivent
        // etre stockes dans le tableau emet_pid

	for(i=0;i<NE;i++){
		if((emet_pid[i]=fork())==0){
			emetteur(i);
			exit(1);
		}
	}

/* creation des processus recepteurs */ 

	// A completer - les pid des processus crees doivent
        // etre stockes dans le tableau recep_pid
	for(i=0;i<NR;i++){
		if ( (recep_pid[i]=fork())==0 ){
			recepteur(i);
			exit(1);
		}
	}


/* redefinition du traitement de Ctrl-C pour arreter le programme */ 

    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    action.sa_handler = handle_sigint;
    sigaction(SIGINT, &action, 0); 
    
    pause();                    /* attente du Ctrl-C  */
		det_sem();
		det_shm(sp);
    return EXIT_SUCCESS;
} 
